(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[177],{837:(n,e,t)=>{Promise.resolve().then(t.t.bind(t,480,23)),Promise.resolve().then(t.t.bind(t,5511,23)),Promise.resolve().then(t.t.bind(t,9556,23)),Promise.resolve().then(t.t.bind(t,6135,23)),Promise.resolve().then(t.t.bind(t,194,23)),Promise.resolve().then(t.bind(t,580)),Promise.resolve().then(t.t.bind(t,1126,23))},580:(n,e,t)=>{"use strict";t.d(e,{Gl:()=>z});var o=t(5155),i=t(6664),r=t(4521),a=t(9059),s=t(8245),v=t(2115),u=t(337),c=t(3093),l=t(1135),m=t(1478),x=t(5879);let p=()=>{let n=(0,v.useRef)(null),e=(0,v.useRef)(null),t=(0,x.c)(n=>n.blobVisible);(0,v.useEffect)(()=>{if(n.current&&e.current){let e=m.Ay.timeline({delay:.2}),o=t?1:.3;e.to(n.current.scale,{x:o,y:o,z:o,duration:1.5,ease:"expo.out"}).to(n.current.position,{y:t?1.5:2,duration:1.5,ease:"expo.out"},0)}},[t]);let i=(0,v.useMemo)(()=>({uTime:{value:0},uSpeed:{value:.5},uFreq:{value:5},uAmp:{value:5},uStrength:{value:.1},uNoiseSize:{value:1},uBrightness:{value:new u.Pq0(.5,.5,.5)},uContrast:{value:new u.Pq0(.5,.5,.5)},uOscilation:{value:new u.Pq0(1,1,1)},uPhase:{value:new u.Pq0(.18,.24,.3)}}),[]);return(0,s.C)(n=>{let{clock:t}=n;e.current&&(e.current.uniforms.uTime.value=t.getElapsedTime())}),(0,o.jsxs)("mesh",{position:[0,1.5,4],"rotation-x":-(.02*Math.PI),ref:n,scale:0,children:[(0,o.jsx)("sphereGeometry",{args:[.6,150,150]}),(0,o.jsx)("rawShaderMaterial",{ref:e,vertexShader:"precision mediump float;\n\n// default uniform\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n// default attribute\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 normal;\n\n// custom uniform\nuniform float uTime;\nuniform float uFreq;\nuniform float uAmp;\nuniform float uStrength;\nuniform float uNoiseSize;\nuniform float uSpeed;\n\n// custom varying\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying float vDistort;\n\n// rotation\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(\n    c, 0.0, -s,\n    0.0, 1.0, 0.0,\n    s, 0.0, c\n  );\n}\n\nvec3 rotateY(vec3 v, float angle) {\n  return rotation3dY(angle) * v;\n}\n\n//	Simplex 4D Noise \n//	by Ian McEwan, Stefan Gustavson (https://github.com/stegu/webgl-noise)\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\nvoid main() {\n  \n  vec3 pos = position;\n  \n  // float distort = snoise(vec4(normal * uNoiseSize, uTime * uSpeed)) * 10.0; // -0.1 - 0.1\n  float distort = snoise(vec4(normal * uNoiseSize, uTime * uSpeed)) * 0.1; // -0.1 - 0.1\n  vec3 direction = normalize(normal);\n  pos += vec3(distort) * direction;\n\n  float angle = sin(uv.y * uFreq + uTime * uSpeed) * uAmp;\n  pos = rotateY(pos, angle);\n\n  vec4 modelPosition = modelMatrix * vec4(pos, 1.0); \n  vec4 viewPosition = viewMatrix * modelPosition;\n  vec4 projectPosition = projectionMatrix * viewPosition;\n\n  gl_Position = projectPosition;\n  \n  vUv = uv;\n  vNormal = normal;\n  vDistort = distort;\n}",fragmentShader:"precision mediump float;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying float vDistort;\n\nuniform vec3 uBrightness;\nuniform vec3 uContrast;\nuniform vec3 uOscilation;\nuniform vec3 uPhase;\n\n\n// Simple color palettes by Inigo Quilez\n// https://iquilezles.org/articles/palettes/\nvec3 cosPalette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid main() {\n  float distort = smoothstep(-0.1, 0.1, vDistort);\n\n  vec3 brightness = uBrightness;\n  vec3 contrast = uContrast;\n  vec3 oscilation = uOscilation; // 周期\n  vec3 phase = uPhase; // 色の位相\n  vec3 color = cosPalette(distort, brightness, contrast, oscilation, phase);\n\n  gl_FragColor = vec4(color, 1.0);\n}",uniforms:i,transparent:!0})]})};function f(n,e){return Math.random()*(e-n)+n}let d=()=>{let n=(0,v.useRef)(null),{positionArray:e,offsetArray:t,randomArray:i}=(0,v.useMemo)(()=>{let n=new Float32Array(720),e=new Float32Array(720),t=new Float32Array(960),o=window.innerWidth,i=o>1440?o/1440:1;for(let o=0;o<240;o++){let r=3*o,a=4*o;n[r]=0,n[r+1]=0,n[r+2]=0,e[r]=f(-7,7)*i,e[r+1]=f(-4,4.5)*i,e[r+2]=f(0,3)*i,t[a]=Math.random(),t[a+1]=Math.random(),t[a+2]=Math.random(),t[a+3]=Math.random()}return{positionArray:n,offsetArray:e,randomArray:t}},[]),r=(0,v.useMemo)(()=>({uTime:{value:0},uSize:{value:6},uColor1:{value:new u.Q1f("#fff")},uColor2:{value:new u.Q1f("rgb(150, 220, 249)")},uAlpha:{value:0}}),[]);return(0,s.C)(e=>{let{clock:t}=e;n.current&&(n.current.uniforms.uTime.value=t.getElapsedTime())}),(0,v.useEffect)(()=>{let e=m.Ay.timeline();n.current&&e.to(n.current.uniforms.uAlpha,{value:1,duration:1.5,ease:"power2.inOut"})},[]),(0,o.jsxs)("points",{position:[0,2.5,0],"rotation-z":[-(.05*Math.PI)],children:[(0,o.jsxs)("bufferGeometry",{children:[(0,o.jsx)("bufferAttribute",{attach:"attributes-position",args:[e,3]}),(0,o.jsx)("bufferAttribute",{attach:"attributes-offset",args:[t,3]}),(0,o.jsx)("bufferAttribute",{attach:"attributes-randomNum",args:[i,4]})]}),(0,o.jsx)("rawShaderMaterial",{ref:n,vertexShader:"precision mediump float;\n\n// default uniform\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n// default attribute\nattribute vec3 position;\nattribute vec3 offset;\nattribute vec4 randomNum;\n\n// custom uniform\nuniform float uTime;\nuniform float uSize;\n\n// custom varying\nvarying vec2 vUv;\nvarying vec4 vRandomNum;\nvarying float vScaleAnimation;\n\nvoid main() {\n  vec3 pos = position;\n  pos += offset;\n  \n  vec4 modelPosition = modelMatrix * vec4(pos, 1.0); \n  vec4 viewPosition = viewMatrix * modelPosition;\n  vec4 projectPosition = projectionMatrix * viewPosition;\n\n  float scaleAnimation = smoothstep(0.0, 1.0, sin(uTime * 0.8 + randomNum.x * 3.14 * 2.0));\n\n  gl_Position = projectPosition;\n  gl_PointSize = uSize * (smoothstep(0.0, 2.5, offset.z) + 1.0) * scaleAnimation;\n  \n  vRandomNum = randomNum;\n  vScaleAnimation = scaleAnimation;\n}",fragmentShader:"precision mediump float;\n\nvarying vec4 vRandomNum;\nvarying float vScaleAnimation;\n\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform float uAlpha;\n\nvoid main() {\n  vec2 newUv = gl_PointCoord;\n  float dist = 1.0 - smoothstep(0.0, 0.5, distance(vec2(0.5), newUv));\n  \n  vec3 color = mix(uColor1, uColor2, vRandomNum.y);\n\n  gl_FragColor = vec4(color, dist * vScaleAnimation * uAlpha);\n}",uniforms:r,transparent:!0,blending:u.EZo})]})},g=()=>{let n=(0,v.useRef)(null),e=(0,v.useRef)(null);(0,s.C)(e=>{let{clock:t}=e;n.current&&(n.current.uniforms.uTime.value=t.getElapsedTime())});let t=(0,v.useMemo)(()=>({uTime:{value:0},uBrightness:{value:new u.Pq0(0,0,0)},uContrast:{value:new u.Pq0(0,0,0)},uOscilation:{value:new u.Pq0(1,1,1)},uPhase:{value:new u.Pq0(.18,.24,.3)}}),[]);return(0,v.useEffect)(()=>{let t=m.Ay.timeline();n.current&&e.current&&t.to(n.current.uniforms.uBrightness.value,{x:.6,y:.6,z:.6,duration:1.2,ease:"power2.out"}).to(n.current.uniforms.uContrast.value,{x:.5,y:.5,z:.5,duration:1.2,ease:"power2.out"},0).to(e.current.position,{y:-2,duration:3,ease:"power2.out"},0)},[]),(0,o.jsxs)("mesh",{position:[0,-.4,5],"rotation-x":-(.5*Math.PI),ref:e,children:[(0,o.jsx)("planeGeometry",{args:[8,15,40,40]}),(0,o.jsx)("rawShaderMaterial",{ref:n,vertexShader:"// default uniform\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n// default attribute\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 normal;\n\n// custom uniform\nuniform float uTime;\n\n// custom varying\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying float vNoise;\n\n//	Simplex 4D Noise \n//	by Ian McEwan, Stefan Gustavson (https://github.com/stegu/webgl-noise)\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nvoid main() {\n  vec3 pos = position;\n\n  float noise = snoise(vec4(position * 0.2, uTime * 0.1 + 100.0)) * 0.5; // -0.5 - 0.5\n\n  pos.z += sin(pos.x + uTime * 1.3) * noise + 0.5;\n  vec4 modelPosition = modelMatrix * vec4(pos, 1.0);\n  vec4 viewPosition = viewMatrix * modelPosition;\n  vec4 projectPosition = projectionMatrix * viewPosition;\n\n  gl_Position = projectPosition;\n  \n  vUv = uv;\n  vPosition = modelPosition.xyz;\n  vNoise = noise;\n}",fragmentShader:"precision mediump float;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform float uTime;\nuniform vec3 uBrightness;\nuniform vec3 uContrast;\nuniform vec3 uOscilation;\nuniform vec3 uPhase;\nvarying float vNoise;\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n// random2d function\n// 0 - 1\n\nfloat random2d(vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// Simple color palettes by Inigo Quilez\n// https://iquilezles.org/articles/palettes/\nvec3 cosPalette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid main() {\n  float brightnessY = smoothstep(0.0, 6.0, vPosition.z);\n  float brightnessX = 1.0 - smoothstep(0.0, 5.0, abs(vPosition.x));\n  float posY = smoothstep(-2.0, 100.0, vPosition.y);\n\n  float edgeFadeX = smoothstep(0.0, 0.5, vUv.x) * smoothstep(1.0, 0.5, vUv.x);\n  float edgeFadeY = smoothstep(0.0, 0.5, vUv.y) * smoothstep(1.0, 0.5, vUv.y);\n  float edgeFade = edgeFadeX * edgeFadeY;\n\n\n  vec3 brightness = uBrightness; \n  vec3 contrast = uContrast;\n  vec3 oscilation = uOscilation; // 周期\n  vec3 phase = uPhase; // 色の位相\n  vec3 color = cosPalette(vPosition.y, brightness, contrast, oscilation, phase) * edgeFade;\n\n  color *= brightnessY * brightnessX;\n\n  gl_FragColor = vec4(color, 1.0);\n\n}",uniforms:t})]})},h=(0,v.forwardRef)((n,e)=>{let t=(0,v.useRef)(null);return(0,v.useImperativeHandle)(e,()=>({camera:t.current}),[]),(0,o.jsxs)("group",{children:[(0,o.jsx)(c.N,{camera:t.current}),(0,o.jsx)(l.u,{makeDefault:!0,ref:t,position:[0,0,10],fov:50,far:1e4,near:.1}),(0,o.jsx)(p,{}),(0,o.jsx)(g,{}),(0,o.jsx)(d,{})]})}),y=()=>{let{size:n}=(0,s.A)(),e=(0,v.useRef)(null),t=(0,v.useRef)(null),i=(0,v.useMemo)(()=>new u.Z58,[]),r=(0,a.j)();(0,s.C)(n=>{e.current&&(e.current.uniforms.uTime.value=n.clock.getElapsedTime()),t.current&&t.current.camera&&(n.gl.setRenderTarget(r),n.gl.render(i,t.current.camera),n.gl.setRenderTarget(null))});let c=(0,v.useMemo)(()=>({uTime:{value:0},uTexture:{value:r.texture},uProgress:{value:0},uScale:{value:1},isBaseScanLine:{value:!0},isGrainNoise:{value:!0},isColorShift:{value:!0}}),[r.texture]);return(0,o.jsxs)(o.Fragment,{children:[(0,s.o)((0,o.jsx)(h,{ref:t}),i),(0,o.jsxs)("mesh",{position:[0,0,0],children:[(0,o.jsx)("planeGeometry",{args:[n.width,n.height,100,100]}),(0,o.jsx)("rawShaderMaterial",{ref:e,vertexShader:"// default uniform\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n// default attribute\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 normal;\n\n// custom uniform\nuniform float uTime;\n\n// custom varying\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n  vec4 viewPosition = viewMatrix * modelPosition;\n  vec4 projectPosition = projectionMatrix * viewPosition;\n\n  gl_Position = projectPosition;\n  \n  vUv = uv;\n}",fragmentShader:"precision mediump float;\n\nuniform sampler2D uTexture;\nuniform float uProgress;\nuniform float uTime;\nuniform bool isBaseScanLine;\nuniform bool isGrainNoise;\nuniform bool isColorShift;\n\nvarying vec2 vUv;\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n// random2d function\n// 0 - 1\nfloat random2d(vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvoid main() {\n  float baseScaneLine = 0.0;\n  float grainNoise = 1.0;\n  vec3 texColor = texture2D(uTexture, vUv).rgb;\n\n  if(isBaseScanLine) {  \n    vec2 newUv = vUv;\n    newUv *= vec2(1.0, 150.0);\n    newUv = fract(newUv - vec2(0.0, uTime * 100.0));\n\n    baseScaneLine = smoothstep(0.0, 0.5, newUv.y); // グラデ1端\n    baseScaneLine *= smoothstep(1.0, 0.5, newUv.y); // グラデ2端\n    baseScaneLine = 1.0 - baseScaneLine; // 反転\n    // baseScaneLine *= 0.03;\n    baseScaneLine *= 0.07;\n  }\n\n  if(isGrainNoise) {\n    vec2 newUv = vUv;\n\n    grainNoise = random2d(newUv + uTime * 0.001) * 0.1; // 0 - 1\n    float brightness = 0.7;\n    grainNoise = mix(brightness, 1.0, grainNoise);\n  }\n\n  if(isColorShift) {\n    float shift1 = 0.04 * 0.15;\n    float shift2 = 0.01 * 0.15;\n    float shift3 = 0.03 * 0.15;\n    float r = texture2D(uTexture, vUv + vec2(shift1, 0.0)).r;\n    float g = texture2D(uTexture, vUv + vec2(shift3, 0.0)).g;\n    float b = texture2D(uTexture, vUv + vec2(shift2, 0.0)).b;\n\n    texColor = vec3(r, g, b);\n  } else {\n    texColor = texture2D(uTexture, vUv).rgb;\n  }\n\n  gl_FragColor = vec4((texColor + baseScaneLine) * grainNoise, 1.0);\n  \n}",uniforms:c})]})]})};var w=t(7054),b=t.n(w);let z=()=>(0,o.jsx)(o.Fragment,{children:(0,o.jsx)("div",{className:b().canvasWrap,children:(0,o.jsxs)(r.Hl,{flat:!0,linear:!0,children:[(0,o.jsx)(i.q,{makeDefault:!0,position:[0,0,2],near:.1,far:100,zoom:1}),(0,o.jsx)(y,{})]})})})},5879:(n,e,t)=>{"use strict";t.d(e,{c:()=>o});let o=(0,t(5532).v)(n=>({blobVisible:!1,setBlobVisible:e=>n({blobVisible:e})}))},1126:()=>{},6135:n=>{n.exports={wrapper:"layout_wrapper__L7TNG"}},194:n=>{n.exports={footer:"footer_footer__XzSYJ",footerText:"footer_footerText__v_OID"}},7054:n=>{n.exports={canvasWrap:"gl_canvasWrap__Ac4pv"}}},n=>{var e=e=>n(n.s=e);n.O(0,[621,277,592,367,831,413,189,623,441,517,358],()=>e(837)),_N_E=n.O()}]);