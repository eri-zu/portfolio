exports.id=964,exports.ids=[964],exports.modules={4162:(e,n,t)=>{Promise.resolve().then(t.t.bind(t,3219,23)),Promise.resolve().then(t.t.bind(t,4863,23)),Promise.resolve().then(t.t.bind(t,5155,23)),Promise.resolve().then(t.t.bind(t,802,23)),Promise.resolve().then(t.t.bind(t,9350,23)),Promise.resolve().then(t.t.bind(t,8530,23)),Promise.resolve().then(t.t.bind(t,8921,23))},1018:(e,n,t)=>{Promise.resolve().then(t.t.bind(t,6959,23)),Promise.resolve().then(t.t.bind(t,3875,23)),Promise.resolve().then(t.t.bind(t,8903,23)),Promise.resolve().then(t.t.bind(t,7174,23)),Promise.resolve().then(t.t.bind(t,4178,23)),Promise.resolve().then(t.t.bind(t,7190,23)),Promise.resolve().then(t.t.bind(t,1365,23))},2139:(e,n,t)=>{Promise.resolve().then(t.bind(t,7217))},2755:(e,n,t)=>{Promise.resolve().then(t.bind(t,6622))},6622:(e,n,t)=>{"use strict";t.d(n,{Gl:()=>j});var o=t(5512),i=t(3201),r=t(6883),s=t(4407),a=t(8354),c=t(8009),l=t(29),u=t(8525),v=t(103),m=t(2138),p=t(2057);let x=()=>{let e=(0,c.useRef)(null),n=(0,c.useRef)(null),t=(0,p.c)(e=>e.blobVisible);(0,c.useEffect)(()=>{if(e.current&&n.current){let n=m.Ay.timeline({delay:.2}),o=t?1:.3;n.to(e.current.scale,{x:o,y:o,z:o,duration:1.5,ease:"expo.out"}).to(e.current.position,{y:t?1.5:2,duration:1.5,ease:"expo.out"},0)}},[t]);let i=(0,c.useMemo)(()=>({uTime:{value:0},uSpeed:{value:.5},uFreq:{value:5},uAmp:{value:5},uStrength:{value:.1},uNoiseSize:{value:1},uBrightness:{value:new l.Pq0(.5,.5,.5)},uContrast:{value:new l.Pq0(.5,.5,.5)},uOscilation:{value:new l.Pq0(1,1,1)},uPhase:{value:new l.Pq0(.18,.24,.3)}}),[]);return(0,a.C)(({clock:e})=>{n.current&&(n.current.uniforms.uTime.value=e.getElapsedTime())}),(0,o.jsxs)("mesh",{position:[0,1.5,4],"rotation-x":-(.02*Math.PI),ref:e,scale:0,children:[(0,o.jsx)("sphereGeometry",{args:[.6,150,150]}),(0,o.jsx)("rawShaderMaterial",{ref:n,vertexShader:"precision mediump float;\n\n// default uniform\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n// default attribute\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 normal;\n\n// custom uniform\nuniform float uTime;\nuniform float uFreq;\nuniform float uAmp;\nuniform float uStrength;\nuniform float uNoiseSize;\nuniform float uSpeed;\n\n// custom varying\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying float vDistort;\n\n// rotation\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(\n    c, 0.0, -s,\n    0.0, 1.0, 0.0,\n    s, 0.0, c\n  );\n}\n\nvec3 rotateY(vec3 v, float angle) {\n  return rotation3dY(angle) * v;\n}\n\n//	Simplex 4D Noise \n//	by Ian McEwan, Stefan Gustavson (https://github.com/stegu/webgl-noise)\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\nvoid main() {\n  \n  vec3 pos = position;\n  \n  // float distort = snoise(vec4(normal * uNoiseSize, uTime * uSpeed)) * 10.0; // -0.1 - 0.1\n  float distort = snoise(vec4(normal * uNoiseSize, uTime * uSpeed)) * 0.1; // -0.1 - 0.1\n  vec3 direction = normalize(normal);\n  pos += vec3(distort) * direction;\n\n  float angle = sin(uv.y * uFreq + uTime * uSpeed) * uAmp;\n  pos = rotateY(pos, angle);\n\n  vec4 modelPosition = modelMatrix * vec4(pos, 1.0); \n  vec4 viewPosition = viewMatrix * modelPosition;\n  vec4 projectPosition = projectionMatrix * viewPosition;\n\n  gl_Position = projectPosition;\n  \n  vUv = uv;\n  vNormal = normal;\n  vDistort = distort;\n}",fragmentShader:"precision mediump float;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying float vDistort;\n\nuniform vec3 uBrightness;\nuniform vec3 uContrast;\nuniform vec3 uOscilation;\nuniform vec3 uPhase;\n\n\n// Simple color palettes by Inigo Quilez\n// https://iquilezles.org/articles/palettes/\nvec3 cosPalette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid main() {\n  float distort = smoothstep(-0.1, 0.1, vDistort);\n\n  vec3 brightness = uBrightness;\n  vec3 contrast = uContrast;\n  vec3 oscilation = uOscilation; // 周期\n  vec3 phase = uPhase; // 色の位相\n  vec3 color = cosPalette(distort, brightness, contrast, oscilation, phase);\n\n  gl_FragColor = vec4(color, 1.0);\n}",uniforms:i,transparent:!0})]})};function d(e,n){return Math.random()*(n-e)+e}let f=()=>{let e=(0,c.useRef)(null),{positionArray:n,offsetArray:t,randomArray:i}=(0,c.useMemo)(()=>{let e=new Float32Array(720),n=new Float32Array(720),t=new Float32Array(960),o=window.innerWidth,i=o>1440?o/1440:1;for(let o=0;o<240;o++){let r=3*o,s=4*o;e[r]=0,e[r+1]=0,e[r+2]=0,n[r]=d(-7,7)*i,n[r+1]=d(-4,4.5)*i,n[r+2]=d(0,3)*i,t[s]=Math.random(),t[s+1]=Math.random(),t[s+2]=Math.random(),t[s+3]=Math.random()}return{positionArray:e,offsetArray:n,randomArray:t}},[]),r=(0,c.useMemo)(()=>({uTime:{value:0},uSize:{value:6},uColor1:{value:new l.Q1f("#fff")},uColor2:{value:new l.Q1f("rgb(150, 220, 249)")},uAlpha:{value:0}}),[]);return(0,a.C)(({clock:n})=>{e.current&&(e.current.uniforms.uTime.value=n.getElapsedTime())}),(0,c.useEffect)(()=>{let n=m.Ay.timeline();e.current&&n.to(e.current.uniforms.uAlpha,{value:1,duration:1.5,ease:"power2.inOut"})},[]),(0,o.jsxs)("points",{position:[0,2.5,0],"rotation-z":[-(.05*Math.PI)],children:[(0,o.jsxs)("bufferGeometry",{children:[(0,o.jsx)("bufferAttribute",{attach:"attributes-position",args:[n,3]}),(0,o.jsx)("bufferAttribute",{attach:"attributes-offset",args:[t,3]}),(0,o.jsx)("bufferAttribute",{attach:"attributes-randomNum",args:[i,4]})]}),(0,o.jsx)("rawShaderMaterial",{ref:e,vertexShader:"precision mediump float;\n\n// default uniform\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n// default attribute\nattribute vec3 position;\nattribute vec3 offset;\nattribute vec4 randomNum;\n\n// custom uniform\nuniform float uTime;\nuniform float uSize;\n\n// custom varying\nvarying vec2 vUv;\nvarying vec4 vRandomNum;\nvarying float vScaleAnimation;\n\nvoid main() {\n  vec3 pos = position;\n  pos += offset;\n  \n  vec4 modelPosition = modelMatrix * vec4(pos, 1.0); \n  vec4 viewPosition = viewMatrix * modelPosition;\n  vec4 projectPosition = projectionMatrix * viewPosition;\n\n  float scaleAnimation = smoothstep(0.0, 1.0, sin(uTime * 0.8 + randomNum.x * 3.14 * 2.0));\n\n  gl_Position = projectPosition;\n  gl_PointSize = uSize * (smoothstep(0.0, 2.5, offset.z) + 1.0) * scaleAnimation;\n  \n  vRandomNum = randomNum;\n  vScaleAnimation = scaleAnimation;\n}",fragmentShader:"precision mediump float;\n\nvarying vec4 vRandomNum;\nvarying float vScaleAnimation;\n\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform float uAlpha;\n\nvoid main() {\n  vec2 newUv = gl_PointCoord;\n  float dist = 1.0 - smoothstep(0.0, 0.5, distance(vec2(0.5), newUv));\n  \n  vec3 color = mix(uColor1, uColor2, vRandomNum.y);\n\n  gl_FragColor = vec4(color, dist * vScaleAnimation * uAlpha);\n}",uniforms:r,transparent:!0,blending:l.EZo})]})},h=()=>{let e=(0,c.useRef)(null),n=(0,c.useRef)(null);(0,a.C)(({clock:n})=>{e.current&&(e.current.uniforms.uTime.value=n.getElapsedTime())});let t=(0,c.useMemo)(()=>({uTime:{value:0},uBrightness:{value:new l.Pq0(0,0,0)},uContrast:{value:new l.Pq0(0,0,0)},uOscilation:{value:new l.Pq0(1,1,1)},uPhase:{value:new l.Pq0(.18,.24,.3)}}),[]);return(0,c.useEffect)(()=>{let t=m.Ay.timeline();e.current&&n.current&&t.to(e.current.uniforms.uBrightness.value,{x:.6,y:.6,z:.6,duration:1.2,ease:"power2.out"}).to(e.current.uniforms.uContrast.value,{x:.5,y:.5,z:.5,duration:1.2,ease:"power2.out"},0).to(n.current.position,{y:-2,duration:3,ease:"power2.out"},0)},[]),(0,o.jsxs)("mesh",{position:[0,-.4,5],"rotation-x":-(.5*Math.PI),ref:n,children:[(0,o.jsx)("planeGeometry",{args:[8,15,40,40]}),(0,o.jsx)("rawShaderMaterial",{ref:e,vertexShader:"// default uniform\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n// default attribute\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 normal;\n\n// custom uniform\nuniform float uTime;\n\n// custom varying\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying float vNoise;\n\n//	Simplex 4D Noise \n//	by Ian McEwan, Stefan Gustavson (https://github.com/stegu/webgl-noise)\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nvoid main() {\n  vec3 pos = position;\n\n  float noise = snoise(vec4(position * 0.2, uTime * 0.1 + 100.0)) * 0.5; // -0.5 - 0.5\n\n  pos.z += sin(pos.x + uTime * 1.3) * noise + 0.5;\n  vec4 modelPosition = modelMatrix * vec4(pos, 1.0);\n  vec4 viewPosition = viewMatrix * modelPosition;\n  vec4 projectPosition = projectionMatrix * viewPosition;\n\n  gl_Position = projectPosition;\n  \n  vUv = uv;\n  vPosition = modelPosition.xyz;\n  vNoise = noise;\n}",fragmentShader:"precision mediump float;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform float uTime;\nuniform vec3 uBrightness;\nuniform vec3 uContrast;\nuniform vec3 uOscilation;\nuniform vec3 uPhase;\nvarying float vNoise;\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n// random2d function\n// 0 - 1\n\nfloat random2d(vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// Simple color palettes by Inigo Quilez\n// https://iquilezles.org/articles/palettes/\nvec3 cosPalette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid main() {\n  float brightnessY = smoothstep(0.0, 6.0, vPosition.z);\n  float brightnessX = 1.0 - smoothstep(0.0, 5.0, abs(vPosition.x));\n  float posY = smoothstep(-2.0, 100.0, vPosition.y);\n\n  float edgeFadeX = smoothstep(0.0, 0.5, vUv.x) * smoothstep(1.0, 0.5, vUv.x);\n  float edgeFadeY = smoothstep(0.0, 0.5, vUv.y) * smoothstep(1.0, 0.5, vUv.y);\n  float edgeFade = edgeFadeX * edgeFadeY;\n\n\n  vec3 brightness = uBrightness; \n  vec3 contrast = uContrast;\n  vec3 oscilation = uOscilation; // 周期\n  vec3 phase = uPhase; // 色の位相\n  vec3 color = cosPalette(vPosition.y, brightness, contrast, oscilation, phase) * edgeFade;\n\n  color *= brightnessY * brightnessX;\n\n  gl_FragColor = vec4(color, 1.0);\n\n}",uniforms:t})]})},g=(0,c.forwardRef)((e,n)=>{let t=(0,c.useRef)(null);return(0,c.useImperativeHandle)(n,()=>({camera:t.current}),[]),(0,o.jsxs)("group",{children:[(0,o.jsx)(u.N,{camera:t.current}),(0,o.jsx)(v.u,{makeDefault:!0,ref:t,position:[0,0,10],fov:50,far:1e4,near:.1}),(0,o.jsx)(x,{}),(0,o.jsx)(h,{}),(0,o.jsx)(f,{})]})}),y=()=>{let{size:e}=(0,a.A)(),n=(0,c.useRef)(null),t=(0,c.useRef)(null),i=(0,c.useMemo)(()=>new l.Z58,[]),r=(0,s.j)();(0,a.C)(e=>{n.current&&(n.current.uniforms.uTime.value=e.clock.getElapsedTime()),t.current&&t.current.camera&&(e.gl.setRenderTarget(r),e.gl.render(i,t.current.camera),e.gl.setRenderTarget(null))});let u=(0,c.useMemo)(()=>({uTime:{value:0},uTexture:{value:r.texture},uProgress:{value:0},uScale:{value:1},isBaseScanLine:{value:!0},isGrainNoise:{value:!0},isColorShift:{value:!0}}),[r.texture]);return(0,o.jsxs)(o.Fragment,{children:[(0,a.o)((0,o.jsx)(g,{ref:t}),i),(0,o.jsxs)("mesh",{position:[0,0,0],children:[(0,o.jsx)("planeGeometry",{args:[e.width,e.height,100,100]}),(0,o.jsx)("rawShaderMaterial",{ref:n,vertexShader:"// default uniform\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\n// default attribute\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 normal;\n\n// custom uniform\nuniform float uTime;\n\n// custom varying\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n  vec4 viewPosition = viewMatrix * modelPosition;\n  vec4 projectPosition = projectionMatrix * viewPosition;\n\n  gl_Position = projectPosition;\n  \n  vUv = uv;\n}",fragmentShader:"precision mediump float;\n\nuniform sampler2D uTexture;\nuniform float uProgress;\nuniform float uTime;\nuniform bool isBaseScanLine;\nuniform bool isGrainNoise;\nuniform bool isColorShift;\n\nvarying vec2 vUv;\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n// random2d function\n// 0 - 1\nfloat random2d(vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvoid main() {\n  float baseScaneLine = 0.0;\n  float grainNoise = 1.0;\n  vec3 texColor = texture2D(uTexture, vUv).rgb;\n\n  if(isBaseScanLine) {  \n    vec2 newUv = vUv;\n    newUv *= vec2(1.0, 150.0);\n    newUv = fract(newUv - vec2(0.0, uTime * 100.0));\n\n    baseScaneLine = smoothstep(0.0, 0.5, newUv.y); // グラデ1端\n    baseScaneLine *= smoothstep(1.0, 0.5, newUv.y); // グラデ2端\n    baseScaneLine = 1.0 - baseScaneLine; // 反転\n    // baseScaneLine *= 0.03;\n    baseScaneLine *= 0.07;\n  }\n\n  if(isGrainNoise) {\n    vec2 newUv = vUv;\n\n    grainNoise = random2d(newUv + uTime * 0.001) * 0.1; // 0 - 1\n    float brightness = 0.7;\n    grainNoise = mix(brightness, 1.0, grainNoise);\n  }\n\n  if(isColorShift) {\n    float shift1 = 0.04 * 0.15;\n    float shift2 = 0.01 * 0.15;\n    float shift3 = 0.03 * 0.15;\n    float r = texture2D(uTexture, vUv + vec2(shift1, 0.0)).r;\n    float g = texture2D(uTexture, vUv + vec2(shift3, 0.0)).g;\n    float b = texture2D(uTexture, vUv + vec2(shift2, 0.0)).b;\n\n    texColor = vec3(r, g, b);\n  } else {\n    texColor = texture2D(uTexture, vUv).rgb;\n  }\n\n  gl_FragColor = vec4((texColor + baseScaneLine) * grainNoise, 1.0);\n  \n}",uniforms:u})]})]})};var b=t(8469),w=t.n(b);let j=()=>(0,o.jsx)(o.Fragment,{children:(0,o.jsx)("div",{className:w().canvasWrap,children:(0,o.jsxs)(r.Hl,{flat:!0,linear:!0,children:[(0,o.jsx)(i.q,{makeDefault:!0,position:[0,0,2],near:.1,far:100,zoom:1}),(0,o.jsx)(y,{})]})})})},2057:(e,n,t)=>{"use strict";t.d(n,{c:()=>o});let o=(0,t(1892).v)(e=>({blobVisible:!1,setBlobVisible:n=>e({blobVisible:n})}))},8292:e=>{e.exports={wrapper:"layout_wrapper__L7TNG"}},5013:e=>{e.exports={footer:"footer_footer__XzSYJ",footerText:"footer_footerText__v_OID"}},8469:e=>{e.exports={canvasWrap:"gl_canvasWrap__Ac4pv"}},742:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>j,metadata:()=>w});var o=t(2740),i=t(5511),r=t(949),s=t.n(r),a=t(7709),c=t.n(a),l=t(2854),u=t.n(l),v=t(57),m=t.n(v),p=t(8292),x=t.n(p),d=t(5013),f=t.n(d);let h=()=>(0,o.jsx)("footer",{className:f().footer,children:(0,o.jsx)("div",{className:f().footerInner,children:(0,o.jsx)("p",{className:f().footerText,children:(0,o.jsxs)("small",{children:["\xa9 ",new Date().getFullYear()," ERI IZUTSU"]})})})});var g=t(7217);t(7691);let y=(0,i.randomBytes)(128).toString("base64"),b=`
  default-src 'self';
	script-src 'self' 'nonce-${y}' https: http:;
	style-src 'self' 'unsafe-inline' https:;
  img-src 'self' data: https:;
  font-src 'self' https:;
	object-src 'none';
	base-uri 'self';
	frame-ancestors 'none';
	upgrade-insecure-requests;
  connect-src 'self' https:;
`,w={title:{default:"portfolio",template:"%s | portfolio"},description:"My personal portfolio showcasing projects.",openGraph:{title:"portfolio",description:"My personal portfolio showcasing projects.",url:"https://eri-zu.github.io/portfolio/htdocs/out/",siteName:"portfolio",images:[{url:"https://eri-zu.github.io/portfolio/htdocs/out/ogp.jpg",width:1200,height:630}],locale:"ja_JP",type:"website"},twitter:{card:"summary_large_image",title:"portfolio",description:"My personal portfolio showcasing projects.",images:["https://eri-zu.github.io/portfolio/htdocs/out/ogp.jpg"]},other:{"Strict-Transport-Security":"max-age=63072000; includeSubDomains; preload","X-Frame-Options":"SAMEORIGIN","Referrer-Policy":"strict-origin-when-cross-origin","Content-Security-Policy":`${b.replace(/\n/g,"")}`}};function j({children:e}){return(0,o.jsx)("html",{lang:"ja",className:s()([c().variable,u().variable,m().variable]),children:(0,o.jsx)("body",{children:(0,o.jsx)("div",{className:x().wrapper,children:(0,o.jsxs)("div",{className:x().inner,children:[(0,o.jsx)(g.Gl,{}),(0,o.jsx)("main",{className:x().main,children:(0,o.jsx)("div",{className:x().mainInner,children:e})}),(0,o.jsx)(h,{})]})})})})}},7217:(e,n,t)=>{"use strict";t.d(n,{Gl:()=>o});let o=(0,t(6760).registerClientReference)(function(){throw Error("Attempted to call Gl() from the server but Gl is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"/Users/eri/selfstudy/portfolio/src/components/layouts/gl/index.tsx","Gl")},7691:()=>{}};